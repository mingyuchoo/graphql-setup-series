### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateCustomer {
  avg: CustomerAvgAggregateOutputType
  count: CustomerCountAggregateOutputType
  max: CustomerMaxAggregateOutputType
  min: CustomerMinAggregateOutputType
  sum: CustomerSumAggregateOutputType
}

type AggregateEmployee {
  avg: EmployeeAvgAggregateOutputType
  count: EmployeeCountAggregateOutputType
  max: EmployeeMaxAggregateOutputType
  min: EmployeeMinAggregateOutputType
  sum: EmployeeSumAggregateOutputType
}

type AggregateOffice {
  count: OfficeCountAggregateOutputType
  max: OfficeMaxAggregateOutputType
  min: OfficeMinAggregateOutputType
}

type AggregateOrder {
  avg: OrderAvgAggregateOutputType
  count: OrderCountAggregateOutputType
  max: OrderMaxAggregateOutputType
  min: OrderMinAggregateOutputType
  sum: OrderSumAggregateOutputType
}

type AggregateOrderDetail {
  avg: OrderDetailAvgAggregateOutputType
  count: OrderDetailCountAggregateOutputType
  max: OrderDetailMaxAggregateOutputType
  min: OrderDetailMinAggregateOutputType
  sum: OrderDetailSumAggregateOutputType
}

type AggregatePayment {
  avg: PaymentAvgAggregateOutputType
  count: PaymentCountAggregateOutputType
  max: PaymentMaxAggregateOutputType
  min: PaymentMinAggregateOutputType
  sum: PaymentSumAggregateOutputType
}

type AggregateProduct {
  avg: ProductAvgAggregateOutputType
  count: ProductCountAggregateOutputType
  max: ProductMaxAggregateOutputType
  min: ProductMinAggregateOutputType
  sum: ProductSumAggregateOutputType
}

type AggregateProductLine {
  count: ProductLineCountAggregateOutputType
  max: ProductLineMaxAggregateOutputType
  min: ProductLineMinAggregateOutputType
}

type BatchPayload {
  count: Int!
}

type Customer {
  addressLine1: String!
  addressLine2: String
  city: String!
  contactFirstName: String!
  contactLastName: String!
  country: String!
  creditLimit: Float
  customerName: String!
  customerNumber: Int!
  Employee: Employee
  Order(cursor: OrderWhereUniqueInput, distinct: OrderScalarFieldEnum, orderBy: OrderOrderByInput, skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  Payment(cursor: PaymentWhereUniqueInput, distinct: PaymentScalarFieldEnum, orderBy: PaymentOrderByInput, skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
  phone: String!
  postalCode: String
  salesRepEmployeeNumber: Int
  state: String
}

type CustomerAvgAggregateOutputType {
  creditLimit: Float
  customerNumber: Float!
  salesRepEmployeeNumber: Float
}

type CustomerCountAggregateOutputType {
  _all: Int!
  addressLine1: Int
  addressLine2: Int
  city: Int
  contactFirstName: Int
  contactLastName: Int
  country: Int
  creditLimit: Int
  customerName: Int
  customerNumber: Int!
  phone: Int
  postalCode: Int
  salesRepEmployeeNumber: Int
  state: Int
}

input CustomerCreateInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  contactFirstName: String!
  contactLastName: String!
  country: String!
  creditLimit: Float
  customerName: String!
  customerNumber: Int!
  Employee: EmployeeCreateOneWithoutCustomerInput
  Order: OrderCreateManyWithoutCustomerInput
  Payment: PaymentCreateManyWithoutCustomerInput
  phone: String!
  postalCode: String
  state: String
}

input CustomerCreateManyWithoutEmployeeInput {
  connect: [CustomerWhereUniqueInput]
  connectOrCreate: [CustomerCreateOrConnectWithoutEmployeeInput]
  create: [CustomerCreateWithoutEmployeeInput]
}

input CustomerCreateOneWithoutOrderInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutOrderInput
  create: CustomerCreateWithoutOrderInput
}

input CustomerCreateOneWithoutPaymentInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutPaymentInput
  create: CustomerCreateWithoutPaymentInput
}

input CustomerCreateOrConnectWithoutEmployeeInput {
  create: CustomerCreateWithoutEmployeeInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutOrderInput {
  create: CustomerCreateWithoutOrderInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutPaymentInput {
  create: CustomerCreateWithoutPaymentInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutEmployeeInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  contactFirstName: String!
  contactLastName: String!
  country: String!
  creditLimit: Float
  customerName: String!
  customerNumber: Int!
  Order: OrderCreateManyWithoutCustomerInput
  Payment: PaymentCreateManyWithoutCustomerInput
  phone: String!
  postalCode: String
  state: String
}

input CustomerCreateWithoutOrderInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  contactFirstName: String!
  contactLastName: String!
  country: String!
  creditLimit: Float
  customerName: String!
  customerNumber: Int!
  Employee: EmployeeCreateOneWithoutCustomerInput
  Payment: PaymentCreateManyWithoutCustomerInput
  phone: String!
  postalCode: String
  state: String
}

input CustomerCreateWithoutPaymentInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  contactFirstName: String!
  contactLastName: String!
  country: String!
  creditLimit: Float
  customerName: String!
  customerNumber: Int!
  Employee: EmployeeCreateOneWithoutCustomerInput
  Order: OrderCreateManyWithoutCustomerInput
  phone: String!
  postalCode: String
  state: String
}

input CustomerListRelationFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

type CustomerMaxAggregateOutputType {
  addressLine1: String
  addressLine2: String
  city: String
  contactFirstName: String
  contactLastName: String
  country: String
  creditLimit: Float
  customerName: String
  customerNumber: Int!
  phone: String
  postalCode: String
  salesRepEmployeeNumber: Int
  state: String
}

type CustomerMinAggregateOutputType {
  addressLine1: String
  addressLine2: String
  city: String
  contactFirstName: String
  contactLastName: String
  country: String
  creditLimit: Float
  customerName: String
  customerNumber: Int!
  phone: String
  postalCode: String
  salesRepEmployeeNumber: Int
  state: String
}

input CustomerOrderByInput {
  addressLine1: SortOrder
  addressLine2: SortOrder
  city: SortOrder
  contactFirstName: SortOrder
  contactLastName: SortOrder
  country: SortOrder
  creditLimit: SortOrder
  customerName: SortOrder
  customerNumber: SortOrder
  phone: SortOrder
  postalCode: SortOrder
  salesRepEmployeeNumber: SortOrder
  state: SortOrder
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  addressLine1
  addressLine2
  city
  contactFirstName
  contactLastName
  country
  creditLimit
  customerName
  customerNumber
  phone
  postalCode
  salesRepEmployeeNumber
  state
}

input CustomerScalarWhereInput {
  addressLine1: StringFilter
  addressLine2: StringNullableFilter
  AND: [CustomerScalarWhereInput]
  city: StringFilter
  contactFirstName: StringFilter
  contactLastName: StringFilter
  country: StringFilter
  creditLimit: FloatNullableFilter
  customerName: StringFilter
  customerNumber: IntFilter
  NOT: [CustomerScalarWhereInput]
  OR: [CustomerScalarWhereInput]
  phone: StringFilter
  postalCode: StringNullableFilter
  salesRepEmployeeNumber: IntNullableFilter
  state: StringNullableFilter
}

type CustomerSumAggregateOutputType {
  creditLimit: Float
  customerNumber: Int!
  salesRepEmployeeNumber: Int
}

input CustomerUpdateInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  contactFirstName: StringFieldUpdateOperationsInput
  contactLastName: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  creditLimit: NullableFloatFieldUpdateOperationsInput
  customerName: StringFieldUpdateOperationsInput
  customerNumber: IntFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutCustomerInput
  Order: OrderUpdateManyWithoutCustomerInput
  Payment: PaymentUpdateManyWithoutCustomerInput
  phone: StringFieldUpdateOperationsInput
  postalCode: NullableStringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateManyMutationInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  contactFirstName: StringFieldUpdateOperationsInput
  contactLastName: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  creditLimit: NullableFloatFieldUpdateOperationsInput
  customerName: StringFieldUpdateOperationsInput
  customerNumber: IntFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postalCode: NullableStringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateManyWithoutEmployeeInput {
  connect: [CustomerWhereUniqueInput]
  connectOrCreate: [CustomerCreateOrConnectWithoutEmployeeInput]
  create: [CustomerCreateWithoutEmployeeInput]
  delete: [CustomerWhereUniqueInput]
  deleteMany: [CustomerScalarWhereInput]
  disconnect: [CustomerWhereUniqueInput]
  set: [CustomerWhereUniqueInput]
  update: [CustomerUpdateWithWhereUniqueWithoutEmployeeInput]
  updateMany: [CustomerUpdateManyWithWhereWithoutEmployeeInput]
  upsert: [CustomerUpsertWithWhereUniqueWithoutEmployeeInput]
}

input CustomerUpdateManyWithWhereWithoutEmployeeInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateOneRequiredWithoutOrderInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutOrderInput
  create: CustomerCreateWithoutOrderInput
  update: CustomerUpdateWithoutOrderInput
  upsert: CustomerUpsertWithoutOrderInput
}

input CustomerUpdateOneRequiredWithoutPaymentInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutPaymentInput
  create: CustomerCreateWithoutPaymentInput
  update: CustomerUpdateWithoutPaymentInput
  upsert: CustomerUpsertWithoutPaymentInput
}

input CustomerUpdateWithoutEmployeeInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  contactFirstName: StringFieldUpdateOperationsInput
  contactLastName: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  creditLimit: NullableFloatFieldUpdateOperationsInput
  customerName: StringFieldUpdateOperationsInput
  customerNumber: IntFieldUpdateOperationsInput
  Order: OrderUpdateManyWithoutCustomerInput
  Payment: PaymentUpdateManyWithoutCustomerInput
  phone: StringFieldUpdateOperationsInput
  postalCode: NullableStringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateWithoutOrderInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  contactFirstName: StringFieldUpdateOperationsInput
  contactLastName: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  creditLimit: NullableFloatFieldUpdateOperationsInput
  customerName: StringFieldUpdateOperationsInput
  customerNumber: IntFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutCustomerInput
  Payment: PaymentUpdateManyWithoutCustomerInput
  phone: StringFieldUpdateOperationsInput
  postalCode: NullableStringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateWithoutPaymentInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  contactFirstName: StringFieldUpdateOperationsInput
  contactLastName: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  creditLimit: NullableFloatFieldUpdateOperationsInput
  customerName: StringFieldUpdateOperationsInput
  customerNumber: IntFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutCustomerInput
  Order: OrderUpdateManyWithoutCustomerInput
  phone: StringFieldUpdateOperationsInput
  postalCode: NullableStringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateWithWhereUniqueWithoutEmployeeInput {
  data: CustomerUpdateWithoutEmployeeInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithoutOrderInput {
  create: CustomerCreateWithoutOrderInput!
  update: CustomerUpdateWithoutOrderInput!
}

input CustomerUpsertWithoutPaymentInput {
  create: CustomerCreateWithoutPaymentInput!
  update: CustomerUpdateWithoutPaymentInput!
}

input CustomerUpsertWithWhereUniqueWithoutEmployeeInput {
  create: CustomerCreateWithoutEmployeeInput!
  update: CustomerUpdateWithoutEmployeeInput!
  where: CustomerWhereUniqueInput!
}

input CustomerWhereInput {
  addressLine1: StringFilter
  addressLine2: StringNullableFilter
  AND: [CustomerWhereInput]
  city: StringFilter
  contactFirstName: StringFilter
  contactLastName: StringFilter
  country: StringFilter
  creditLimit: FloatNullableFilter
  customerName: StringFilter
  customerNumber: IntFilter
  Employee: EmployeeWhereInput
  NOT: [CustomerWhereInput]
  OR: [CustomerWhereInput]
  Order: OrderListRelationFilter
  Payment: PaymentListRelationFilter
  phone: StringFilter
  postalCode: StringNullableFilter
  salesRepEmployeeNumber: IntNullableFilter
  state: StringNullableFilter
}

input CustomerWhereUniqueInput {
  customerNumber: Int
}

"""Date custom scalar type"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime]
}

type Employee {
  Customer(cursor: CustomerWhereUniqueInput, distinct: CustomerScalarFieldEnum, orderBy: CustomerOrderByInput, skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  email: String!
  Employee: Employee
  employeeNumber: Int!
  extension: String!
  firstName: String!
  jobTitle: String!
  lastName: String!
  Office: Office!
  officeCode: String!
  other_employees(cursor: EmployeeWhereUniqueInput, distinct: EmployeeScalarFieldEnum, orderBy: EmployeeOrderByInput, skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  reportsTo: Int
}

type EmployeeAvgAggregateOutputType {
  employeeNumber: Float!
  reportsTo: Float
}

type EmployeeCountAggregateOutputType {
  _all: Int!
  email: Int
  employeeNumber: Int!
  extension: Int
  firstName: Int
  jobTitle: Int
  lastName: Int
  officeCode: Int
  reportsTo: Int
}

input EmployeeCreateInput {
  Customer: CustomerCreateManyWithoutEmployeeInput
  email: String!
  Employee: EmployeeCreateOneWithoutOther_employeesInput
  employeeNumber: Int!
  extension: String!
  firstName: String!
  jobTitle: String!
  lastName: String!
  Office: OfficeCreateOneWithoutEmployeeInput!
  other_employees: EmployeeCreateManyWithoutEmployeeInput
}

input EmployeeCreateManyWithoutEmployeeInput {
  connect: [EmployeeWhereUniqueInput]
  connectOrCreate: [EmployeeCreateOrConnectWithoutEmployeeInput]
  create: [EmployeeCreateWithoutEmployeeInput]
}

input EmployeeCreateManyWithoutOfficeInput {
  connect: [EmployeeWhereUniqueInput]
  connectOrCreate: [EmployeeCreateOrConnectWithoutOfficeInput]
  create: [EmployeeCreateWithoutOfficeInput]
}

input EmployeeCreateOneWithoutCustomerInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutCustomerInput
  create: EmployeeCreateWithoutCustomerInput
}

input EmployeeCreateOneWithoutOther_employeesInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutother_employeesInput
  create: EmployeeCreateWithoutOther_employeesInput
}

input EmployeeCreateOrConnectWithoutCustomerInput {
  create: EmployeeCreateWithoutCustomerInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateOrConnectWithoutEmployeeInput {
  create: EmployeeCreateWithoutEmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateOrConnectWithoutOfficeInput {
  create: EmployeeCreateWithoutOfficeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateOrConnectWithoutother_employeesInput {
  create: EmployeeCreateWithoutOther_employeesInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateWithoutCustomerInput {
  email: String!
  Employee: EmployeeCreateOneWithoutOther_employeesInput
  employeeNumber: Int!
  extension: String!
  firstName: String!
  jobTitle: String!
  lastName: String!
  Office: OfficeCreateOneWithoutEmployeeInput!
  other_employees: EmployeeCreateManyWithoutEmployeeInput
}

input EmployeeCreateWithoutEmployeeInput {
  Customer: CustomerCreateManyWithoutEmployeeInput
  email: String!
  employeeNumber: Int!
  extension: String!
  firstName: String!
  jobTitle: String!
  lastName: String!
  Office: OfficeCreateOneWithoutEmployeeInput!
  other_employees: EmployeeCreateManyWithoutEmployeeInput
}

input EmployeeCreateWithoutOfficeInput {
  Customer: CustomerCreateManyWithoutEmployeeInput
  email: String!
  Employee: EmployeeCreateOneWithoutOther_employeesInput
  employeeNumber: Int!
  extension: String!
  firstName: String!
  jobTitle: String!
  lastName: String!
  other_employees: EmployeeCreateManyWithoutEmployeeInput
}

input EmployeeCreateWithoutOther_employeesInput {
  Customer: CustomerCreateManyWithoutEmployeeInput
  email: String!
  Employee: EmployeeCreateOneWithoutOther_employeesInput
  employeeNumber: Int!
  extension: String!
  firstName: String!
  jobTitle: String!
  lastName: String!
  Office: OfficeCreateOneWithoutEmployeeInput!
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  none: EmployeeWhereInput
  some: EmployeeWhereInput
}

type EmployeeMaxAggregateOutputType {
  email: String
  employeeNumber: Int!
  extension: String
  firstName: String
  jobTitle: String
  lastName: String
  officeCode: String
  reportsTo: Int
}

type EmployeeMinAggregateOutputType {
  email: String
  employeeNumber: Int!
  extension: String
  firstName: String
  jobTitle: String
  lastName: String
  officeCode: String
  reportsTo: Int
}

input EmployeeOrderByInput {
  email: SortOrder
  employeeNumber: SortOrder
  extension: SortOrder
  firstName: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  officeCode: SortOrder
  reportsTo: SortOrder
}

input EmployeeRelationFilter {
  is: EmployeeWhereInput
  isNot: EmployeeWhereInput
}

enum EmployeeScalarFieldEnum {
  email
  employeeNumber
  extension
  firstName
  jobTitle
  lastName
  officeCode
  reportsTo
}

input EmployeeScalarWhereInput {
  AND: [EmployeeScalarWhereInput]
  email: StringFilter
  employeeNumber: IntFilter
  extension: StringFilter
  firstName: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  NOT: [EmployeeScalarWhereInput]
  officeCode: StringFilter
  OR: [EmployeeScalarWhereInput]
  reportsTo: IntNullableFilter
}

type EmployeeSumAggregateOutputType {
  employeeNumber: Int!
  reportsTo: Int
}

input EmployeeUpdateInput {
  Customer: CustomerUpdateManyWithoutEmployeeInput
  email: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_employeesInput
  employeeNumber: IntFieldUpdateOperationsInput
  extension: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  jobTitle: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  Office: OfficeUpdateOneRequiredWithoutEmployeeInput
  other_employees: EmployeeUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  employeeNumber: IntFieldUpdateOperationsInput
  extension: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  jobTitle: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input EmployeeUpdateManyWithoutEmployeeInput {
  connect: [EmployeeWhereUniqueInput]
  connectOrCreate: [EmployeeCreateOrConnectWithoutEmployeeInput]
  create: [EmployeeCreateWithoutEmployeeInput]
  delete: [EmployeeWhereUniqueInput]
  deleteMany: [EmployeeScalarWhereInput]
  disconnect: [EmployeeWhereUniqueInput]
  set: [EmployeeWhereUniqueInput]
  update: [EmployeeUpdateWithWhereUniqueWithoutEmployeeInput]
  updateMany: [EmployeeUpdateManyWithWhereWithoutEmployeeInput]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutEmployeeInput]
}

input EmployeeUpdateManyWithoutOfficeInput {
  connect: [EmployeeWhereUniqueInput]
  connectOrCreate: [EmployeeCreateOrConnectWithoutOfficeInput]
  create: [EmployeeCreateWithoutOfficeInput]
  delete: [EmployeeWhereUniqueInput]
  deleteMany: [EmployeeScalarWhereInput]
  disconnect: [EmployeeWhereUniqueInput]
  set: [EmployeeWhereUniqueInput]
  update: [EmployeeUpdateWithWhereUniqueWithoutOfficeInput]
  updateMany: [EmployeeUpdateManyWithWhereWithoutOfficeInput]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutOfficeInput]
}

input EmployeeUpdateManyWithWhereWithoutEmployeeInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateManyWithWhereWithoutOfficeInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateOneWithoutCustomerInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutCustomerInput
  create: EmployeeCreateWithoutCustomerInput
  delete: Boolean
  disconnect: Boolean
  update: EmployeeUpdateWithoutCustomerInput
  upsert: EmployeeUpsertWithoutCustomerInput
}

input EmployeeUpdateOneWithoutOther_employeesInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutother_employeesInput
  create: EmployeeCreateWithoutOther_employeesInput
  delete: Boolean
  disconnect: Boolean
  update: EmployeeUpdateWithoutOther_employeesInput
  upsert: EmployeeUpsertWithoutOther_employeesInput
}

input EmployeeUpdateWithoutCustomerInput {
  email: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_employeesInput
  employeeNumber: IntFieldUpdateOperationsInput
  extension: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  jobTitle: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  Office: OfficeUpdateOneRequiredWithoutEmployeeInput
  other_employees: EmployeeUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateWithoutEmployeeInput {
  Customer: CustomerUpdateManyWithoutEmployeeInput
  email: StringFieldUpdateOperationsInput
  employeeNumber: IntFieldUpdateOperationsInput
  extension: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  jobTitle: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  Office: OfficeUpdateOneRequiredWithoutEmployeeInput
  other_employees: EmployeeUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateWithoutOfficeInput {
  Customer: CustomerUpdateManyWithoutEmployeeInput
  email: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_employeesInput
  employeeNumber: IntFieldUpdateOperationsInput
  extension: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  jobTitle: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  other_employees: EmployeeUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateWithoutOther_employeesInput {
  Customer: CustomerUpdateManyWithoutEmployeeInput
  email: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_employeesInput
  employeeNumber: IntFieldUpdateOperationsInput
  extension: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  jobTitle: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  Office: OfficeUpdateOneRequiredWithoutEmployeeInput
}

input EmployeeUpdateWithWhereUniqueWithoutEmployeeInput {
  data: EmployeeUpdateWithoutEmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithWhereUniqueWithoutOfficeInput {
  data: EmployeeUpdateWithoutOfficeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpsertWithoutCustomerInput {
  create: EmployeeCreateWithoutCustomerInput!
  update: EmployeeUpdateWithoutCustomerInput!
}

input EmployeeUpsertWithoutOther_employeesInput {
  create: EmployeeCreateWithoutOther_employeesInput!
  update: EmployeeUpdateWithoutOther_employeesInput!
}

input EmployeeUpsertWithWhereUniqueWithoutEmployeeInput {
  create: EmployeeCreateWithoutEmployeeInput!
  update: EmployeeUpdateWithoutEmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpsertWithWhereUniqueWithoutOfficeInput {
  create: EmployeeCreateWithoutOfficeInput!
  update: EmployeeUpdateWithoutOfficeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput]
  Customer: CustomerListRelationFilter
  email: StringFilter
  Employee: EmployeeWhereInput
  employeeNumber: IntFilter
  extension: StringFilter
  firstName: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  NOT: [EmployeeWhereInput]
  Office: OfficeWhereInput
  officeCode: StringFilter
  OR: [EmployeeWhereInput]
  other_employees: EmployeeListRelationFilter
  reportsTo: IntNullableFilter
}

input EmployeeWhereUniqueInput {
  employeeNumber: Int
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

"""Json custom scalar type"""
scalar Json

type Mutation {
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneOffice(data: OfficeCreateInput!): Office!
  createOneOrder(data: OrderCreateInput!): Order!
  createOneOrderDetail(data: OrderDetailCreateInput!): OrderDetail!
  createOnePayment(data: PaymentCreateInput!): Payment!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneProductLine(data: ProductLineCreateInput!): ProductLine!
  deleteManyCustomer(where: CustomerWhereInput): BatchPayload!
  deleteManyEmployee(where: EmployeeWhereInput): BatchPayload!
  deleteManyOffice(where: OfficeWhereInput): BatchPayload!
  deleteManyOrder(where: OrderWhereInput): BatchPayload!
  deleteManyOrderDetail(where: OrderDetailWhereInput): BatchPayload!
  deleteManyPayment(where: PaymentWhereInput): BatchPayload!
  deleteManyProduct(where: ProductWhereInput): BatchPayload!
  deleteManyProductLine(where: ProductLineWhereInput): BatchPayload!
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteOneOffice(where: OfficeWhereUniqueInput!): Office
  deleteOneOrder(where: OrderWhereUniqueInput!): Order
  deleteOneOrderDetail(where: OrderDetailWhereUniqueInput!): OrderDetail
  deleteOnePayment(where: PaymentWhereUniqueInput!): Payment
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  deleteOneProductLine(where: ProductLineWhereUniqueInput!): ProductLine
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  updateManyEmployee(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  updateManyOffice(data: OfficeUpdateManyMutationInput!, where: OfficeWhereInput): BatchPayload!
  updateManyOrder(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  updateManyOrderDetail(data: OrderDetailUpdateManyMutationInput!, where: OrderDetailWhereInput): BatchPayload!
  updateManyPayment(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  updateManyProductLine(data: ProductLineUpdateManyMutationInput!, where: ProductLineWhereInput): BatchPayload!
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  updateOneOffice(data: OfficeUpdateInput!, where: OfficeWhereUniqueInput!): Office!
  updateOneOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order!
  updateOneOrderDetail(data: OrderDetailUpdateInput!, where: OrderDetailWhereUniqueInput!): OrderDetail!
  updateOnePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment!
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  updateOneProductLine(data: ProductLineUpdateInput!, where: ProductLineWhereUniqueInput!): ProductLine!
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneEmployee(create: EmployeeCreateInput!, update: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  upsertOneOffice(create: OfficeCreateInput!, update: OfficeUpdateInput!, where: OfficeWhereUniqueInput!): Office!
  upsertOneOrder(create: OrderCreateInput!, update: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order!
  upsertOneOrderDetail(create: OrderDetailCreateInput!, update: OrderDetailUpdateInput!, where: OrderDetailWhereUniqueInput!): OrderDetail!
  upsertOnePayment(create: PaymentCreateInput!, update: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment!
  upsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneProductLine(create: ProductLineCreateInput!, update: ProductLineUpdateInput!, where: ProductLineWhereUniqueInput!): ProductLine!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableFloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Office {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  Employee(cursor: EmployeeWhereUniqueInput, distinct: EmployeeScalarFieldEnum, orderBy: EmployeeOrderByInput, skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  officeCode: String!
  phone: String!
  postalCode: String!
  state: String
  territory: String!
}

type OfficeCountAggregateOutputType {
  _all: Int!
  addressLine1: Int
  addressLine2: Int
  city: Int
  country: Int
  officeCode: Int
  phone: Int
  postalCode: Int
  state: Int
  territory: Int
}

input OfficeCreateInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  Employee: EmployeeCreateManyWithoutOfficeInput
  officeCode: String!
  phone: String!
  postalCode: String!
  state: String
  territory: String!
}

input OfficeCreateOneWithoutEmployeeInput {
  connect: OfficeWhereUniqueInput
  connectOrCreate: OfficeCreateOrConnectWithoutEmployeeInput
  create: OfficeCreateWithoutEmployeeInput
}

input OfficeCreateOrConnectWithoutEmployeeInput {
  create: OfficeCreateWithoutEmployeeInput!
  where: OfficeWhereUniqueInput!
}

input OfficeCreateWithoutEmployeeInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  officeCode: String!
  phone: String!
  postalCode: String!
  state: String
  territory: String!
}

type OfficeMaxAggregateOutputType {
  addressLine1: String
  addressLine2: String
  city: String
  country: String
  officeCode: String
  phone: String
  postalCode: String
  state: String
  territory: String
}

type OfficeMinAggregateOutputType {
  addressLine1: String
  addressLine2: String
  city: String
  country: String
  officeCode: String
  phone: String
  postalCode: String
  state: String
  territory: String
}

input OfficeOrderByInput {
  addressLine1: SortOrder
  addressLine2: SortOrder
  city: SortOrder
  country: SortOrder
  officeCode: SortOrder
  phone: SortOrder
  postalCode: SortOrder
  state: SortOrder
  territory: SortOrder
}

input OfficeRelationFilter {
  is: OfficeWhereInput
  isNot: OfficeWhereInput
}

enum OfficeScalarFieldEnum {
  addressLine1
  addressLine2
  city
  country
  officeCode
  phone
  postalCode
  state
  territory
}

input OfficeUpdateInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateManyWithoutOfficeInput
  officeCode: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postalCode: StringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
  territory: StringFieldUpdateOperationsInput
}

input OfficeUpdateManyMutationInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  officeCode: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postalCode: StringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
  territory: StringFieldUpdateOperationsInput
}

input OfficeUpdateOneRequiredWithoutEmployeeInput {
  connect: OfficeWhereUniqueInput
  connectOrCreate: OfficeCreateOrConnectWithoutEmployeeInput
  create: OfficeCreateWithoutEmployeeInput
  update: OfficeUpdateWithoutEmployeeInput
  upsert: OfficeUpsertWithoutEmployeeInput
}

input OfficeUpdateWithoutEmployeeInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  officeCode: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postalCode: StringFieldUpdateOperationsInput
  state: NullableStringFieldUpdateOperationsInput
  territory: StringFieldUpdateOperationsInput
}

input OfficeUpsertWithoutEmployeeInput {
  create: OfficeCreateWithoutEmployeeInput!
  update: OfficeUpdateWithoutEmployeeInput!
}

input OfficeWhereInput {
  addressLine1: StringFilter
  addressLine2: StringNullableFilter
  AND: [OfficeWhereInput]
  city: StringFilter
  country: StringFilter
  Employee: EmployeeListRelationFilter
  NOT: [OfficeWhereInput]
  officeCode: StringFilter
  OR: [OfficeWhereInput]
  phone: StringFilter
  postalCode: StringFilter
  state: StringNullableFilter
  territory: StringFilter
}

input OfficeWhereUniqueInput {
  officeCode: String
}

type Order {
  comments: String
  Customer: Customer!
  customerNumber: Int!
  orderDate: DateTime!
  OrderDetail(cursor: OrderDetailWhereUniqueInput, distinct: OrderDetailScalarFieldEnum, orderBy: OrderDetailOrderByInput, skip: Int, take: Int, where: OrderDetailWhereInput): [OrderDetail!]!
  orderNumber: Int!
  requiredDate: DateTime!
  shippedDate: DateTime
  status: String!
}

type OrderAvgAggregateOutputType {
  customerNumber: Float!
  orderNumber: Float!
}

type OrderCountAggregateOutputType {
  _all: Int!
  comments: Int
  customerNumber: Int!
  orderDate: Int
  orderNumber: Int!
  requiredDate: Int
  shippedDate: Int
  status: Int
}

input OrderCreateInput {
  comments: String
  Customer: CustomerCreateOneWithoutOrderInput!
  orderDate: DateTime!
  OrderDetail: OrderDetailCreateManyWithoutOrderInput
  orderNumber: Int!
  requiredDate: DateTime!
  shippedDate: DateTime
  status: String!
}

input OrderCreateManyWithoutCustomerInput {
  connect: [OrderWhereUniqueInput]
  connectOrCreate: [OrderCreateOrConnectWithoutCustomerInput]
  create: [OrderCreateWithoutCustomerInput]
}

input OrderCreateOneWithoutOrderDetailInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutOrderDetailInput
  create: OrderCreateWithoutOrderDetailInput
}

input OrderCreateOrConnectWithoutCustomerInput {
  create: OrderCreateWithoutCustomerInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateOrConnectWithoutOrderDetailInput {
  create: OrderCreateWithoutOrderDetailInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateWithoutCustomerInput {
  comments: String
  orderDate: DateTime!
  OrderDetail: OrderDetailCreateManyWithoutOrderInput
  orderNumber: Int!
  requiredDate: DateTime!
  shippedDate: DateTime
  status: String!
}

input OrderCreateWithoutOrderDetailInput {
  comments: String
  Customer: CustomerCreateOneWithoutOrderInput!
  orderDate: DateTime!
  orderNumber: Int!
  requiredDate: DateTime!
  shippedDate: DateTime
  status: String!
}

type OrderDetail {
  Order: Order!
  orderLineNumber: Int!
  orderNumber: Int!
  priceEach: Float!
  Product: Product!
  productCode: String!
  quantityOrdered: Int!
}

type OrderDetailAvgAggregateOutputType {
  orderLineNumber: Float!
  orderNumber: Float!
  priceEach: Float!
  quantityOrdered: Float!
}

type OrderDetailCountAggregateOutputType {
  _all: Int!
  orderLineNumber: Int!
  orderNumber: Int!
  priceEach: Int!
  productCode: Int
  quantityOrdered: Int!
}

input OrderDetailCreateInput {
  Order: OrderCreateOneWithoutOrderDetailInput!
  orderLineNumber: Int!
  priceEach: Float!
  Product: ProductCreateOneWithoutOrderDetailInput!
  quantityOrdered: Int!
}

input OrderDetailCreateManyWithoutOrderInput {
  connect: [OrderDetailWhereUniqueInput]
  connectOrCreate: [OrderDetailCreateOrConnectWithoutOrderInput]
  create: [OrderDetailCreateWithoutOrderInput]
}

input OrderDetailCreateManyWithoutProductInput {
  connect: [OrderDetailWhereUniqueInput]
  connectOrCreate: [OrderDetailCreateOrConnectWithoutProductInput]
  create: [OrderDetailCreateWithoutProductInput]
}

input OrderDetailCreateOrConnectWithoutOrderInput {
  create: OrderDetailCreateWithoutOrderInput!
  where: OrderDetailWhereUniqueInput!
}

input OrderDetailCreateOrConnectWithoutProductInput {
  create: OrderDetailCreateWithoutProductInput!
  where: OrderDetailWhereUniqueInput!
}

input OrderDetailCreateWithoutOrderInput {
  orderLineNumber: Int!
  priceEach: Float!
  Product: ProductCreateOneWithoutOrderDetailInput!
  quantityOrdered: Int!
}

input OrderDetailCreateWithoutProductInput {
  Order: OrderCreateOneWithoutOrderDetailInput!
  orderLineNumber: Int!
  priceEach: Float!
  quantityOrdered: Int!
}

input OrderDetailListRelationFilter {
  every: OrderDetailWhereInput
  none: OrderDetailWhereInput
  some: OrderDetailWhereInput
}

type OrderDetailMaxAggregateOutputType {
  orderLineNumber: Int!
  orderNumber: Int!
  priceEach: Float!
  productCode: String
  quantityOrdered: Int!
}

type OrderDetailMinAggregateOutputType {
  orderLineNumber: Int!
  orderNumber: Int!
  priceEach: Float!
  productCode: String
  quantityOrdered: Int!
}

input OrderDetailOrderByInput {
  orderLineNumber: SortOrder
  orderNumber: SortOrder
  priceEach: SortOrder
  productCode: SortOrder
  quantityOrdered: SortOrder
}

input OrderDetailOrderNumberProductCodeCompoundUniqueInput {
  orderNumber: Int!
  productCode: String!
}

enum OrderDetailScalarFieldEnum {
  orderLineNumber
  orderNumber
  priceEach
  productCode
  quantityOrdered
}

input OrderDetailScalarWhereInput {
  AND: [OrderDetailScalarWhereInput]
  NOT: [OrderDetailScalarWhereInput]
  OR: [OrderDetailScalarWhereInput]
  orderLineNumber: IntFilter
  orderNumber: IntFilter
  priceEach: FloatFilter
  productCode: StringFilter
  quantityOrdered: IntFilter
}

type OrderDetailSumAggregateOutputType {
  orderLineNumber: Int!
  orderNumber: Int!
  priceEach: Float!
  quantityOrdered: Int!
}

input OrderDetailUpdateInput {
  Order: OrderUpdateOneRequiredWithoutOrderDetailInput
  orderLineNumber: IntFieldUpdateOperationsInput
  priceEach: FloatFieldUpdateOperationsInput
  Product: ProductUpdateOneRequiredWithoutOrderDetailInput
  quantityOrdered: IntFieldUpdateOperationsInput
}

input OrderDetailUpdateManyMutationInput {
  orderLineNumber: IntFieldUpdateOperationsInput
  priceEach: FloatFieldUpdateOperationsInput
  quantityOrdered: IntFieldUpdateOperationsInput
}

input OrderDetailUpdateManyWithoutOrderInput {
  connect: [OrderDetailWhereUniqueInput]
  connectOrCreate: [OrderDetailCreateOrConnectWithoutOrderInput]
  create: [OrderDetailCreateWithoutOrderInput]
  delete: [OrderDetailWhereUniqueInput]
  deleteMany: [OrderDetailScalarWhereInput]
  disconnect: [OrderDetailWhereUniqueInput]
  set: [OrderDetailWhereUniqueInput]
  update: [OrderDetailUpdateWithWhereUniqueWithoutOrderInput]
  updateMany: [OrderDetailUpdateManyWithWhereWithoutOrderInput]
  upsert: [OrderDetailUpsertWithWhereUniqueWithoutOrderInput]
}

input OrderDetailUpdateManyWithoutProductInput {
  connect: [OrderDetailWhereUniqueInput]
  connectOrCreate: [OrderDetailCreateOrConnectWithoutProductInput]
  create: [OrderDetailCreateWithoutProductInput]
  delete: [OrderDetailWhereUniqueInput]
  deleteMany: [OrderDetailScalarWhereInput]
  disconnect: [OrderDetailWhereUniqueInput]
  set: [OrderDetailWhereUniqueInput]
  update: [OrderDetailUpdateWithWhereUniqueWithoutProductInput]
  updateMany: [OrderDetailUpdateManyWithWhereWithoutProductInput]
  upsert: [OrderDetailUpsertWithWhereUniqueWithoutProductInput]
}

input OrderDetailUpdateManyWithWhereWithoutOrderInput {
  data: OrderDetailUpdateManyMutationInput!
  where: OrderDetailScalarWhereInput!
}

input OrderDetailUpdateManyWithWhereWithoutProductInput {
  data: OrderDetailUpdateManyMutationInput!
  where: OrderDetailScalarWhereInput!
}

input OrderDetailUpdateWithoutOrderInput {
  orderLineNumber: IntFieldUpdateOperationsInput
  priceEach: FloatFieldUpdateOperationsInput
  Product: ProductUpdateOneRequiredWithoutOrderDetailInput
  quantityOrdered: IntFieldUpdateOperationsInput
}

input OrderDetailUpdateWithoutProductInput {
  Order: OrderUpdateOneRequiredWithoutOrderDetailInput
  orderLineNumber: IntFieldUpdateOperationsInput
  priceEach: FloatFieldUpdateOperationsInput
  quantityOrdered: IntFieldUpdateOperationsInput
}

input OrderDetailUpdateWithWhereUniqueWithoutOrderInput {
  data: OrderDetailUpdateWithoutOrderInput!
  where: OrderDetailWhereUniqueInput!
}

input OrderDetailUpdateWithWhereUniqueWithoutProductInput {
  data: OrderDetailUpdateWithoutProductInput!
  where: OrderDetailWhereUniqueInput!
}

input OrderDetailUpsertWithWhereUniqueWithoutOrderInput {
  create: OrderDetailCreateWithoutOrderInput!
  update: OrderDetailUpdateWithoutOrderInput!
  where: OrderDetailWhereUniqueInput!
}

input OrderDetailUpsertWithWhereUniqueWithoutProductInput {
  create: OrderDetailCreateWithoutProductInput!
  update: OrderDetailUpdateWithoutProductInput!
  where: OrderDetailWhereUniqueInput!
}

input OrderDetailWhereInput {
  AND: [OrderDetailWhereInput]
  NOT: [OrderDetailWhereInput]
  OR: [OrderDetailWhereInput]
  Order: OrderWhereInput
  orderLineNumber: IntFilter
  orderNumber: IntFilter
  priceEach: FloatFilter
  Product: ProductWhereInput
  productCode: StringFilter
  quantityOrdered: IntFilter
}

input OrderDetailWhereUniqueInput {
  orderNumber_productCode: OrderDetailOrderNumberProductCodeCompoundUniqueInput
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

type OrderMaxAggregateOutputType {
  comments: String
  customerNumber: Int!
  orderDate: DateTime
  orderNumber: Int!
  requiredDate: DateTime
  shippedDate: DateTime
  status: String
}

type OrderMinAggregateOutputType {
  comments: String
  customerNumber: Int!
  orderDate: DateTime
  orderNumber: Int!
  requiredDate: DateTime
  shippedDate: DateTime
  status: String
}

input OrderOrderByInput {
  comments: SortOrder
  customerNumber: SortOrder
  orderDate: SortOrder
  orderNumber: SortOrder
  requiredDate: SortOrder
  shippedDate: SortOrder
  status: SortOrder
}

input OrderRelationFilter {
  is: OrderWhereInput
  isNot: OrderWhereInput
}

enum OrderScalarFieldEnum {
  comments
  customerNumber
  orderDate
  orderNumber
  requiredDate
  shippedDate
  status
}

input OrderScalarWhereInput {
  AND: [OrderScalarWhereInput]
  comments: StringNullableFilter
  customerNumber: IntFilter
  NOT: [OrderScalarWhereInput]
  OR: [OrderScalarWhereInput]
  orderDate: DateTimeFilter
  orderNumber: IntFilter
  requiredDate: DateTimeFilter
  shippedDate: DateTimeNullableFilter
  status: StringFilter
}

type OrderSumAggregateOutputType {
  customerNumber: Int!
  orderNumber: Int!
}

input OrderUpdateInput {
  comments: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateOneRequiredWithoutOrderInput
  orderDate: DateTimeFieldUpdateOperationsInput
  OrderDetail: OrderDetailUpdateManyWithoutOrderInput
  orderNumber: IntFieldUpdateOperationsInput
  requiredDate: DateTimeFieldUpdateOperationsInput
  shippedDate: NullableDateTimeFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
}

input OrderUpdateManyMutationInput {
  comments: NullableStringFieldUpdateOperationsInput
  orderDate: DateTimeFieldUpdateOperationsInput
  orderNumber: IntFieldUpdateOperationsInput
  requiredDate: DateTimeFieldUpdateOperationsInput
  shippedDate: NullableDateTimeFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
}

input OrderUpdateManyWithoutCustomerInput {
  connect: [OrderWhereUniqueInput]
  connectOrCreate: [OrderCreateOrConnectWithoutCustomerInput]
  create: [OrderCreateWithoutCustomerInput]
  delete: [OrderWhereUniqueInput]
  deleteMany: [OrderScalarWhereInput]
  disconnect: [OrderWhereUniqueInput]
  set: [OrderWhereUniqueInput]
  update: [OrderUpdateWithWhereUniqueWithoutCustomerInput]
  updateMany: [OrderUpdateManyWithWhereWithoutCustomerInput]
  upsert: [OrderUpsertWithWhereUniqueWithoutCustomerInput]
}

input OrderUpdateManyWithWhereWithoutCustomerInput {
  data: OrderUpdateManyMutationInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateOneRequiredWithoutOrderDetailInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutOrderDetailInput
  create: OrderCreateWithoutOrderDetailInput
  update: OrderUpdateWithoutOrderDetailInput
  upsert: OrderUpsertWithoutOrderDetailInput
}

input OrderUpdateWithoutCustomerInput {
  comments: NullableStringFieldUpdateOperationsInput
  orderDate: DateTimeFieldUpdateOperationsInput
  OrderDetail: OrderDetailUpdateManyWithoutOrderInput
  orderNumber: IntFieldUpdateOperationsInput
  requiredDate: DateTimeFieldUpdateOperationsInput
  shippedDate: NullableDateTimeFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
}

input OrderUpdateWithoutOrderDetailInput {
  comments: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateOneRequiredWithoutOrderInput
  orderDate: DateTimeFieldUpdateOperationsInput
  orderNumber: IntFieldUpdateOperationsInput
  requiredDate: DateTimeFieldUpdateOperationsInput
  shippedDate: NullableDateTimeFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
}

input OrderUpdateWithWhereUniqueWithoutCustomerInput {
  data: OrderUpdateWithoutCustomerInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithoutOrderDetailInput {
  create: OrderCreateWithoutOrderDetailInput!
  update: OrderUpdateWithoutOrderDetailInput!
}

input OrderUpsertWithWhereUniqueWithoutCustomerInput {
  create: OrderCreateWithoutCustomerInput!
  update: OrderUpdateWithoutCustomerInput!
  where: OrderWhereUniqueInput!
}

input OrderWhereInput {
  AND: [OrderWhereInput]
  comments: StringNullableFilter
  Customer: CustomerWhereInput
  customerNumber: IntFilter
  NOT: [OrderWhereInput]
  OR: [OrderWhereInput]
  orderDate: DateTimeFilter
  OrderDetail: OrderDetailListRelationFilter
  orderNumber: IntFilter
  requiredDate: DateTimeFilter
  shippedDate: DateTimeNullableFilter
  status: StringFilter
}

input OrderWhereUniqueInput {
  orderNumber: Int
}

type Payment {
  amount: Float!
  checkNumber: String!
  Customer: Customer!
  customerNumber: Int!
  paymentDate: DateTime!
}

type PaymentAvgAggregateOutputType {
  amount: Float!
  customerNumber: Float!
}

type PaymentCountAggregateOutputType {
  _all: Int!
  amount: Int!
  checkNumber: Int
  customerNumber: Int!
  paymentDate: Int
}

input PaymentCreateInput {
  amount: Float!
  checkNumber: String!
  Customer: CustomerCreateOneWithoutPaymentInput!
  paymentDate: DateTime!
}

input PaymentCreateManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput]
  connectOrCreate: [PaymentCreateOrConnectWithoutCustomerInput]
  create: [PaymentCreateWithoutCustomerInput]
}

input PaymentCreateOrConnectWithoutCustomerInput {
  create: PaymentCreateWithoutCustomerInput!
  where: PaymentWhereUniqueInput!
}

input PaymentCreateWithoutCustomerInput {
  amount: Float!
  checkNumber: String!
  paymentDate: DateTime!
}

input PaymentCustomerNumberCheckNumberCompoundUniqueInput {
  checkNumber: String!
  customerNumber: Int!
}

input PaymentListRelationFilter {
  every: PaymentWhereInput
  none: PaymentWhereInput
  some: PaymentWhereInput
}

type PaymentMaxAggregateOutputType {
  amount: Float!
  checkNumber: String
  customerNumber: Int!
  paymentDate: DateTime
}

type PaymentMinAggregateOutputType {
  amount: Float!
  checkNumber: String
  customerNumber: Int!
  paymentDate: DateTime
}

input PaymentOrderByInput {
  amount: SortOrder
  checkNumber: SortOrder
  customerNumber: SortOrder
  paymentDate: SortOrder
}

enum PaymentScalarFieldEnum {
  amount
  checkNumber
  customerNumber
  paymentDate
}

input PaymentScalarWhereInput {
  amount: FloatFilter
  AND: [PaymentScalarWhereInput]
  checkNumber: StringFilter
  customerNumber: IntFilter
  NOT: [PaymentScalarWhereInput]
  OR: [PaymentScalarWhereInput]
  paymentDate: DateTimeFilter
}

type PaymentSumAggregateOutputType {
  amount: Float!
  customerNumber: Int!
}

input PaymentUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  checkNumber: StringFieldUpdateOperationsInput
  Customer: CustomerUpdateOneRequiredWithoutPaymentInput
  paymentDate: DateTimeFieldUpdateOperationsInput
}

input PaymentUpdateManyMutationInput {
  amount: FloatFieldUpdateOperationsInput
  checkNumber: StringFieldUpdateOperationsInput
  paymentDate: DateTimeFieldUpdateOperationsInput
}

input PaymentUpdateManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput]
  connectOrCreate: [PaymentCreateOrConnectWithoutCustomerInput]
  create: [PaymentCreateWithoutCustomerInput]
  delete: [PaymentWhereUniqueInput]
  deleteMany: [PaymentScalarWhereInput]
  disconnect: [PaymentWhereUniqueInput]
  set: [PaymentWhereUniqueInput]
  update: [PaymentUpdateWithWhereUniqueWithoutCustomerInput]
  updateMany: [PaymentUpdateManyWithWhereWithoutCustomerInput]
  upsert: [PaymentUpsertWithWhereUniqueWithoutCustomerInput]
}

input PaymentUpdateManyWithWhereWithoutCustomerInput {
  data: PaymentUpdateManyMutationInput!
  where: PaymentScalarWhereInput!
}

input PaymentUpdateWithoutCustomerInput {
  amount: FloatFieldUpdateOperationsInput
  checkNumber: StringFieldUpdateOperationsInput
  paymentDate: DateTimeFieldUpdateOperationsInput
}

input PaymentUpdateWithWhereUniqueWithoutCustomerInput {
  data: PaymentUpdateWithoutCustomerInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithWhereUniqueWithoutCustomerInput {
  create: PaymentCreateWithoutCustomerInput!
  update: PaymentUpdateWithoutCustomerInput!
  where: PaymentWhereUniqueInput!
}

input PaymentWhereInput {
  amount: FloatFilter
  AND: [PaymentWhereInput]
  checkNumber: StringFilter
  Customer: CustomerWhereInput
  customerNumber: IntFilter
  NOT: [PaymentWhereInput]
  OR: [PaymentWhereInput]
  paymentDate: DateTimeFilter
}

input PaymentWhereUniqueInput {
  customerNumber_checkNumber: PaymentCustomerNumberCheckNumberCompoundUniqueInput
}

type Product {
  buyPrice: Float!
  MSRP: Float!
  OrderDetail(cursor: OrderDetailWhereUniqueInput, distinct: OrderDetailScalarFieldEnum, orderBy: OrderDetailOrderByInput, skip: Int, take: Int, where: OrderDetailWhereInput): [OrderDetail!]!
  productCode: String!
  productDescription: String!
  productLine: String!
  ProductLine: ProductLine!
  productName: String!
  productScale: String!
  productVendor: String!
  quantityInStock: Int!
}

type ProductAvgAggregateOutputType {
  buyPrice: Float!
  MSRP: Float!
  quantityInStock: Float!
}

type ProductCountAggregateOutputType {
  _all: Int!
  buyPrice: Int!
  MSRP: Int!
  productCode: Int
  productDescription: Int
  productLine: Int
  productName: Int
  productScale: Int
  productVendor: Int
  quantityInStock: Int!
}

input ProductCreateInput {
  buyPrice: Float!
  MSRP: Float!
  OrderDetail: OrderDetailCreateManyWithoutProductInput
  productCode: String!
  productDescription: String!
  ProductLine: ProductLineCreateOneWithoutProductInput!
  productName: String!
  productScale: String!
  productVendor: String!
  quantityInStock: Int!
}

input ProductCreateManyWithoutProductLineInput {
  connect: [ProductWhereUniqueInput]
  connectOrCreate: [ProductCreateOrConnectWithoutProductLineInput]
  create: [ProductCreateWithoutProductLineInput]
}

input ProductCreateOneWithoutOrderDetailInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOrderDetailInput
  create: ProductCreateWithoutOrderDetailInput
}

input ProductCreateOrConnectWithoutOrderDetailInput {
  create: ProductCreateWithoutOrderDetailInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutProductLineInput {
  create: ProductCreateWithoutProductLineInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutOrderDetailInput {
  buyPrice: Float!
  MSRP: Float!
  productCode: String!
  productDescription: String!
  ProductLine: ProductLineCreateOneWithoutProductInput!
  productName: String!
  productScale: String!
  productVendor: String!
  quantityInStock: Int!
}

input ProductCreateWithoutProductLineInput {
  buyPrice: Float!
  MSRP: Float!
  OrderDetail: OrderDetailCreateManyWithoutProductInput
  productCode: String!
  productDescription: String!
  productName: String!
  productScale: String!
  productVendor: String!
  quantityInStock: Int!
}

type ProductLine {
  htmlDescription: String
  image: String
  Product(cursor: ProductWhereUniqueInput, distinct: ProductScalarFieldEnum, orderBy: ProductOrderByInput, skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  productLine: String!
  textDescription: String
}

type ProductLineCountAggregateOutputType {
  _all: Int!
  htmlDescription: Int
  image: Int
  productLine: Int
  textDescription: Int
}

input ProductLineCreateInput {
  htmlDescription: String
  image: String
  Product: ProductCreateManyWithoutProductLineInput
  productLine: String!
  textDescription: String
}

input ProductLineCreateOneWithoutProductInput {
  connect: ProductLineWhereUniqueInput
  connectOrCreate: ProductLineCreateOrConnectWithoutProductInput
  create: ProductLineCreateWithoutProductInput
}

input ProductLineCreateOrConnectWithoutProductInput {
  create: ProductLineCreateWithoutProductInput!
  where: ProductLineWhereUniqueInput!
}

input ProductLineCreateWithoutProductInput {
  htmlDescription: String
  image: String
  productLine: String!
  textDescription: String
}

type ProductLineMaxAggregateOutputType {
  htmlDescription: String
  image: String
  productLine: String
  textDescription: String
}

type ProductLineMinAggregateOutputType {
  htmlDescription: String
  image: String
  productLine: String
  textDescription: String
}

input ProductLineOrderByInput {
  htmlDescription: SortOrder
  image: SortOrder
  productLine: SortOrder
  textDescription: SortOrder
}

input ProductLineRelationFilter {
  is: ProductLineWhereInput
  isNot: ProductLineWhereInput
}

enum ProductLineScalarFieldEnum {
  htmlDescription
  image
  productLine
  textDescription
}

input ProductLineUpdateInput {
  htmlDescription: NullableStringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  Product: ProductUpdateManyWithoutProductLineInput
  productLine: StringFieldUpdateOperationsInput
  textDescription: NullableStringFieldUpdateOperationsInput
}

input ProductLineUpdateManyMutationInput {
  htmlDescription: NullableStringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  productLine: StringFieldUpdateOperationsInput
  textDescription: NullableStringFieldUpdateOperationsInput
}

input ProductLineUpdateOneRequiredWithoutProductInput {
  connect: ProductLineWhereUniqueInput
  connectOrCreate: ProductLineCreateOrConnectWithoutProductInput
  create: ProductLineCreateWithoutProductInput
  update: ProductLineUpdateWithoutProductInput
  upsert: ProductLineUpsertWithoutProductInput
}

input ProductLineUpdateWithoutProductInput {
  htmlDescription: NullableStringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  productLine: StringFieldUpdateOperationsInput
  textDescription: NullableStringFieldUpdateOperationsInput
}

input ProductLineUpsertWithoutProductInput {
  create: ProductLineCreateWithoutProductInput!
  update: ProductLineUpdateWithoutProductInput!
}

input ProductLineWhereInput {
  AND: [ProductLineWhereInput]
  htmlDescription: StringNullableFilter
  image: StringNullableFilter
  NOT: [ProductLineWhereInput]
  OR: [ProductLineWhereInput]
  Product: ProductListRelationFilter
  productLine: StringFilter
  textDescription: StringNullableFilter
}

input ProductLineWhereUniqueInput {
  productLine: String
}

input ProductListRelationFilter {
  every: ProductWhereInput
  none: ProductWhereInput
  some: ProductWhereInput
}

type ProductMaxAggregateOutputType {
  buyPrice: Float!
  MSRP: Float!
  productCode: String
  productDescription: String
  productLine: String
  productName: String
  productScale: String
  productVendor: String
  quantityInStock: Int!
}

type ProductMinAggregateOutputType {
  buyPrice: Float!
  MSRP: Float!
  productCode: String
  productDescription: String
  productLine: String
  productName: String
  productScale: String
  productVendor: String
  quantityInStock: Int!
}

input ProductOrderByInput {
  buyPrice: SortOrder
  MSRP: SortOrder
  productCode: SortOrder
  productDescription: SortOrder
  productLine: SortOrder
  productName: SortOrder
  productScale: SortOrder
  productVendor: SortOrder
  quantityInStock: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

enum ProductScalarFieldEnum {
  buyPrice
  MSRP
  productCode
  productDescription
  productLine
  productName
  productScale
  productVendor
  quantityInStock
}

input ProductScalarWhereInput {
  AND: [ProductScalarWhereInput]
  buyPrice: FloatFilter
  MSRP: FloatFilter
  NOT: [ProductScalarWhereInput]
  OR: [ProductScalarWhereInput]
  productCode: StringFilter
  productDescription: StringFilter
  productLine: StringFilter
  productName: StringFilter
  productScale: StringFilter
  productVendor: StringFilter
  quantityInStock: IntFilter
}

type ProductSumAggregateOutputType {
  buyPrice: Float!
  MSRP: Float!
  quantityInStock: Int!
}

input ProductUpdateInput {
  buyPrice: FloatFieldUpdateOperationsInput
  MSRP: FloatFieldUpdateOperationsInput
  OrderDetail: OrderDetailUpdateManyWithoutProductInput
  productCode: StringFieldUpdateOperationsInput
  productDescription: StringFieldUpdateOperationsInput
  ProductLine: ProductLineUpdateOneRequiredWithoutProductInput
  productName: StringFieldUpdateOperationsInput
  productScale: StringFieldUpdateOperationsInput
  productVendor: StringFieldUpdateOperationsInput
  quantityInStock: IntFieldUpdateOperationsInput
}

input ProductUpdateManyMutationInput {
  buyPrice: FloatFieldUpdateOperationsInput
  MSRP: FloatFieldUpdateOperationsInput
  productCode: StringFieldUpdateOperationsInput
  productDescription: StringFieldUpdateOperationsInput
  productName: StringFieldUpdateOperationsInput
  productScale: StringFieldUpdateOperationsInput
  productVendor: StringFieldUpdateOperationsInput
  quantityInStock: IntFieldUpdateOperationsInput
}

input ProductUpdateManyWithoutProductLineInput {
  connect: [ProductWhereUniqueInput]
  connectOrCreate: [ProductCreateOrConnectWithoutProductLineInput]
  create: [ProductCreateWithoutProductLineInput]
  delete: [ProductWhereUniqueInput]
  deleteMany: [ProductScalarWhereInput]
  disconnect: [ProductWhereUniqueInput]
  set: [ProductWhereUniqueInput]
  update: [ProductUpdateWithWhereUniqueWithoutProductLineInput]
  updateMany: [ProductUpdateManyWithWhereWithoutProductLineInput]
  upsert: [ProductUpsertWithWhereUniqueWithoutProductLineInput]
}

input ProductUpdateManyWithWhereWithoutProductLineInput {
  data: ProductUpdateManyMutationInput!
  where: ProductScalarWhereInput!
}

input ProductUpdateOneRequiredWithoutOrderDetailInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOrderDetailInput
  create: ProductCreateWithoutOrderDetailInput
  update: ProductUpdateWithoutOrderDetailInput
  upsert: ProductUpsertWithoutOrderDetailInput
}

input ProductUpdateWithoutOrderDetailInput {
  buyPrice: FloatFieldUpdateOperationsInput
  MSRP: FloatFieldUpdateOperationsInput
  productCode: StringFieldUpdateOperationsInput
  productDescription: StringFieldUpdateOperationsInput
  ProductLine: ProductLineUpdateOneRequiredWithoutProductInput
  productName: StringFieldUpdateOperationsInput
  productScale: StringFieldUpdateOperationsInput
  productVendor: StringFieldUpdateOperationsInput
  quantityInStock: IntFieldUpdateOperationsInput
}

input ProductUpdateWithoutProductLineInput {
  buyPrice: FloatFieldUpdateOperationsInput
  MSRP: FloatFieldUpdateOperationsInput
  OrderDetail: OrderDetailUpdateManyWithoutProductInput
  productCode: StringFieldUpdateOperationsInput
  productDescription: StringFieldUpdateOperationsInput
  productName: StringFieldUpdateOperationsInput
  productScale: StringFieldUpdateOperationsInput
  productVendor: StringFieldUpdateOperationsInput
  quantityInStock: IntFieldUpdateOperationsInput
}

input ProductUpdateWithWhereUniqueWithoutProductLineInput {
  data: ProductUpdateWithoutProductLineInput!
  where: ProductWhereUniqueInput!
}

input ProductUpsertWithoutOrderDetailInput {
  create: ProductCreateWithoutOrderDetailInput!
  update: ProductUpdateWithoutOrderDetailInput!
}

input ProductUpsertWithWhereUniqueWithoutProductLineInput {
  create: ProductCreateWithoutProductLineInput!
  update: ProductUpdateWithoutProductLineInput!
  where: ProductWhereUniqueInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput]
  buyPrice: FloatFilter
  MSRP: FloatFilter
  NOT: [ProductWhereInput]
  OR: [ProductWhereInput]
  OrderDetail: OrderDetailListRelationFilter
  productCode: StringFilter
  productDescription: StringFilter
  productLine: StringFilter
  ProductLine: ProductLineWhereInput
  productName: StringFilter
  productScale: StringFilter
  productVendor: StringFilter
  quantityInStock: IntFilter
}

input ProductWhereUniqueInput {
  productCode: String
}

type Query {
  aggregateCustomer(cursor: CustomerWhereUniqueInput, distinct: CustomerScalarFieldEnum, orderBy: [CustomerOrderByInput], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer
  aggregateEmployee(cursor: EmployeeWhereUniqueInput, distinct: EmployeeScalarFieldEnum, orderBy: [EmployeeOrderByInput], skip: Int, take: Int, where: EmployeeWhereInput): AggregateEmployee
  aggregateOffice(cursor: OfficeWhereUniqueInput, distinct: OfficeScalarFieldEnum, orderBy: [OfficeOrderByInput], skip: Int, take: Int, where: OfficeWhereInput): AggregateOffice
  aggregateOrder(cursor: OrderWhereUniqueInput, distinct: OrderScalarFieldEnum, orderBy: [OrderOrderByInput], skip: Int, take: Int, where: OrderWhereInput): AggregateOrder
  aggregateOrderDetail(cursor: OrderDetailWhereUniqueInput, distinct: OrderDetailScalarFieldEnum, orderBy: [OrderDetailOrderByInput], skip: Int, take: Int, where: OrderDetailWhereInput): AggregateOrderDetail
  aggregatePayment(cursor: PaymentWhereUniqueInput, distinct: PaymentScalarFieldEnum, orderBy: [PaymentOrderByInput], skip: Int, take: Int, where: PaymentWhereInput): AggregatePayment
  aggregateProduct(cursor: ProductWhereUniqueInput, distinct: ProductScalarFieldEnum, orderBy: [ProductOrderByInput], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct
  aggregateProductLine(cursor: ProductLineWhereUniqueInput, distinct: ProductLineScalarFieldEnum, orderBy: [ProductLineOrderByInput], skip: Int, take: Int, where: ProductLineWhereInput): AggregateProductLine
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: CustomerScalarFieldEnum, orderBy: [CustomerOrderByInput], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstEmployee(cursor: EmployeeWhereUniqueInput, distinct: EmployeeScalarFieldEnum, orderBy: [EmployeeOrderByInput], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstOffice(cursor: OfficeWhereUniqueInput, distinct: OfficeScalarFieldEnum, orderBy: [OfficeOrderByInput], skip: Int, take: Int, where: OfficeWhereInput): Office
  findFirstOrder(cursor: OrderWhereUniqueInput, distinct: OrderScalarFieldEnum, orderBy: [OrderOrderByInput], skip: Int, take: Int, where: OrderWhereInput): Order
  findFirstOrderDetail(cursor: OrderDetailWhereUniqueInput, distinct: OrderDetailScalarFieldEnum, orderBy: [OrderDetailOrderByInput], skip: Int, take: Int, where: OrderDetailWhereInput): OrderDetail
  findFirstPayment(cursor: PaymentWhereUniqueInput, distinct: PaymentScalarFieldEnum, orderBy: [PaymentOrderByInput], skip: Int, take: Int, where: PaymentWhereInput): Payment
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: ProductScalarFieldEnum, orderBy: [ProductOrderByInput], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductLine(cursor: ProductLineWhereUniqueInput, distinct: ProductLineScalarFieldEnum, orderBy: [ProductLineOrderByInput], skip: Int, take: Int, where: ProductLineWhereInput): ProductLine
  findManyCustomer(cursor: CustomerWhereUniqueInput, distinct: CustomerScalarFieldEnum, orderBy: [CustomerOrderByInput], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  findManyCustomerCount(cursor: CustomerWhereUniqueInput, distinct: CustomerScalarFieldEnum, orderBy: [CustomerOrderByInput], skip: Int, take: Int, where: CustomerWhereInput): Int!
  findManyEmployee(cursor: EmployeeWhereUniqueInput, distinct: EmployeeScalarFieldEnum, orderBy: [EmployeeOrderByInput], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  findManyEmployeeCount(cursor: EmployeeWhereUniqueInput, distinct: EmployeeScalarFieldEnum, orderBy: [EmployeeOrderByInput], skip: Int, take: Int, where: EmployeeWhereInput): Int!
  findManyOffice(cursor: OfficeWhereUniqueInput, distinct: OfficeScalarFieldEnum, orderBy: [OfficeOrderByInput], skip: Int, take: Int, where: OfficeWhereInput): [Office!]!
  findManyOfficeCount(cursor: OfficeWhereUniqueInput, distinct: OfficeScalarFieldEnum, orderBy: [OfficeOrderByInput], skip: Int, take: Int, where: OfficeWhereInput): Int!
  findManyOrder(cursor: OrderWhereUniqueInput, distinct: OrderScalarFieldEnum, orderBy: [OrderOrderByInput], skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  findManyOrderCount(cursor: OrderWhereUniqueInput, distinct: OrderScalarFieldEnum, orderBy: [OrderOrderByInput], skip: Int, take: Int, where: OrderWhereInput): Int!
  findManyOrderDetail(cursor: OrderDetailWhereUniqueInput, distinct: OrderDetailScalarFieldEnum, orderBy: [OrderDetailOrderByInput], skip: Int, take: Int, where: OrderDetailWhereInput): [OrderDetail!]!
  findManyOrderDetailCount(cursor: OrderDetailWhereUniqueInput, distinct: OrderDetailScalarFieldEnum, orderBy: [OrderDetailOrderByInput], skip: Int, take: Int, where: OrderDetailWhereInput): Int!
  findManyPayment(cursor: PaymentWhereUniqueInput, distinct: PaymentScalarFieldEnum, orderBy: [PaymentOrderByInput], skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
  findManyPaymentCount(cursor: PaymentWhereUniqueInput, distinct: PaymentScalarFieldEnum, orderBy: [PaymentOrderByInput], skip: Int, take: Int, where: PaymentWhereInput): Int!
  findManyProduct(cursor: ProductWhereUniqueInput, distinct: ProductScalarFieldEnum, orderBy: [ProductOrderByInput], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  findManyProductCount(cursor: ProductWhereUniqueInput, distinct: ProductScalarFieldEnum, orderBy: [ProductOrderByInput], skip: Int, take: Int, where: ProductWhereInput): Int!
  findManyProductLine(cursor: ProductLineWhereUniqueInput, distinct: ProductLineScalarFieldEnum, orderBy: [ProductLineOrderByInput], skip: Int, take: Int, where: ProductLineWhereInput): [ProductLine!]!
  findManyProductLineCount(cursor: ProductLineWhereUniqueInput, distinct: ProductLineScalarFieldEnum, orderBy: [ProductLineOrderByInput], skip: Int, take: Int, where: ProductLineWhereInput): Int!
  findUniqueCustomer(where: CustomerWhereUniqueInput): Customer
  findUniqueEmployee(where: EmployeeWhereUniqueInput): Employee
  findUniqueOffice(where: OfficeWhereUniqueInput): Office
  findUniqueOrder(where: OrderWhereUniqueInput): Order
  findUniqueOrderDetail(where: OrderDetailWhereUniqueInput): OrderDetail
  findUniquePayment(where: PaymentWhereUniqueInput): Payment
  findUniqueProduct(where: ProductWhereUniqueInput): Product
  findUniqueProductLine(where: ProductLineWhereUniqueInput): ProductLine
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}
